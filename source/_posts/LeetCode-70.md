---
title: LeetCode_70.Climbing Stairs 爬楼梯
date: 2020-03-10 15:37:24
tags: "LeetCode"
categories: "LeetCode"
---
## 题目描述
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。
<!--more-->

### 示例1：
```
输入： 2   
输出： 2   
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```
### 示例2:
```
输入： 3   
输出： 3   
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

## 题解：
### 方法1：递归 自顶向下
>PS：(暴力但并不可取)

**思路**   
这个题看第一眼的时候觉得不知道是哪种题，手算了两个之后发现其实跟斐波那契数列很相似：

>假设梯子有n层，每次只能爬 1 或者 2 层，
那么爬到顶的方法要么是
1，从第 n-1层 爬 1 层登顶
2，从第 n-2 层 爬 2层 登顶
两种方法相加就是爬到顶的所有方法
所以递推一下就有
S(n) = S(n-1) + S(n-2)
这个基础思路
且S(n)是个分段函数 当 n=1 或者 n=2 的时候有直接结果返回 只有当 n>2 的时候才有递推公式

**算法**
```java
class Solution {
    public int climbStairs(int n) {
      if (n == 1)
        return 1;
      if (n == 2)
        return 2;
      return climbStairs(n-1) + climbStairs(n-2);
    }
}
```

**分析**
* 时间复杂度(2^n):二叉树形式 指数阶   
* 空间复杂度O(1):使用常量空间   

这种方法直接，但是因为采用递归，会产生很多重复的计算：   
比如当n=5时   
想要计算 S(5) 就要知道 S(4) 和 S(3)   
想要计算 S(4)/S(3) 就要计算S(3)/S(2)….   
这里看出 递归树中S(4)下面的子树 包含了S(3)这个树的所有计算内容   
当n越来越大时 重复计算了相当多的数据 必然会造成时间浪费   
时间复杂度为O(2^n)   
拿到OJ上跑 也是显示 **<font color=#FF4500> Time Limit Exceeded</font>** 运行超时

### 方法2：优化递归 尾递归
>PS：(方法一的优化版本)可能比较抽象

**思路**   
因为方法1 的算法运行超时 直接原因是重复的计算过多   
那我们如果倒过来想 增加一个额外计数器的概念，记录一下需要经过多少次计算，并设置一下结束递归条件，把多余的计算过程都省去，时间上便可以得到优化   
继续使用方法1中的递归算法：

>假设梯子有6层 n=6
因为当n=1时候 可以直接知道只有 1 种情况
当 n=2 时候 可以直接知道只有 2 种情况
每进行一次计算 n 减 1
1，当n=6时候 计算第一个需要计算的层数:S(3)=1+2 计算之后n-1=5
2，当n=5时候 计算第二个需要计算的层数:S(4)=S(3)+2 计算之后n-1=4
3，当n=4时候 计算第三个需要计算的层数:S(5)=S(4)+S(3) 计算之后n-1=3
4，当n=3时候 计算第四个需要计算的层数:S(6)=S(5)+S(4) 计算之后n-1=2
5，因为到这里 第二层的方法次数不需要计算 直接知道有2种 所以把 n=2时 设置成结束递归条件

从例子中看出每次计算直接可以用到上一次计算的结果 不需要重复进行多余的运算 但是想法可能有点绕 开始Coding…

**算法**
```java
class Solution {
    public int climbStairs(int n) {
        return climb(n,1,2);
    }
    public static int climb(int n,int n1,int n2){
        if (n == 1)
            return n1;
        if (n == 2)
            return n2;
        return climb(--n, n2, n1 + n2);
        }
}
```
**分析**

* 时间复杂度O(n):需要计算n个数值 线性阶   
* 空间复杂度O(1):使用常量空间

主要是一个加入计数器的思想思路
n1 n2 代表计算的两个值 最初带入 1 和 2
每次计算结束后如果还需要计算则变换参与计算的值,不需要计算时 返回最终计算的出的那个值就可以(n2)

### 方法3：循环计算
**思路**   
换种思路 递归说到底，就是自己调用自己，是一种无穷迭代思维方式，简单粗暴的罗列。递归对程序员的修养要求极高，能不用就尽量别用。   
设一个存值变量使用循环进行运算

**算法**
```java
class Solution {
    public int climbStairs(int n) {
      int n1 = 1;
      int n2 = 2;
      int temp;
      for (int i = 2; i < n ; i++) {
          temp = n2;
          n2 = n1 + n2;
          n1 = temp;
      }
      return n<=2 ? n : n2;
    }
}
```
**分析**

* 时间复杂度O(n):单循环到n 需要计算n个数值
* 空间复杂度O(1):使用常量空间

### 方法4：数学公式
**思路**    
这个我打死也想不到 我是看题解才知道 其实斐波那契数列是可以求出通项公式的，   
推理的过程请参见 知乎上的这个贴子，那么有了通项公式后，直接在常数级的时间复杂度范围内就可以求出结果了   
只能说 数学才是算法的艺术核心啊。   
参见代码如下：

**算法**
```java
public class Solution {
    public int climbStairs(int n) {
        double sqrt5=Math.sqrt(5);
        double fibn=Math.pow((1+sqrt5)/2,n+1)-Math.pow((1-sqrt5)/2,n+1);
        return (int)(fibn/sqrt5);
    }
}
```
**分析**

* 时间复杂度O(log(n)):pow 方法将会用去 log(n)的时间。
* 空间复杂度O(1): 使用常量级空间。

## 更多题解详见：
[LeetCode 个人题解汇总(持续更新....)](https://www.macchac.com/2020/03/10/LeetCode-ALL/)
