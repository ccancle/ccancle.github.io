<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-cat.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-cat.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://macchac.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="最近重新过了一遍网络的基础内容，之前看这个问题的时候觉得这个问题也没有多少东西可说，但是现在重新来看这个题目的时候，发现之前是没有一个相对完整的知识体系，这个问题基本上可以囊括一大半的网络基础知识内容 本次重新梳理一下这个问题的内容，其实换个角度看，这个问题也是在问HTTP请求的完整过程。 （也当是重新回学校之后开始整理博客的第一篇吧）">
<meta property="og:type" content="article">
<meta property="og:title" content="当你在浏览器中输入Url之后发生了什么">
<meta property="og:url" content="http://macchac.com/2021/03/29/urll/index.html">
<meta property="og:site_name" content="來日可期">
<meta property="og:description" content="最近重新过了一遍网络的基础内容，之前看这个问题的时候觉得这个问题也没有多少东西可说，但是现在重新来看这个题目的时候，发现之前是没有一个相对完整的知识体系，这个问题基本上可以囊括一大半的网络基础知识内容 本次重新梳理一下这个问题的内容，其实换个角度看，这个问题也是在问HTTP请求的完整过程。 （也当是重新回学校之后开始整理博客的第一篇吧）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://macchac.com/.com//HTTP-Cache.jpg">
<meta property="og:image" content="http://macchac.com/.com//endpoint.jpg">
<meta property="og:image" content="http://macchac.com/.com//DNS.png">
<meta property="og:image" content="http://macchac.com/.com//CDN.png">
<meta property="og:image" content="http://macchac.com/.com//progress.jpg">
<meta property="og:image" content="http://macchac.com/.com//tcpCenter.png">
<meta property="og:image" content="http://macchac.com/.com//shackhands.png">
<meta property="og:image" content="http://macchac.com/.com//shakehand3.png">
<meta property="og:image" content="http://macchac.com/.com//shakehand2.png">
<meta property="og:image" content="http://macchac.com/.com//resend.png">
<meta property="og:image" content="http://macchac.com/.com//CacheSimple.png">
<meta property="og:image" content="http://macchac.com/.com//cacheProcess.jpg">
<meta property="og:image" content="http://macchac.com/.com//StrongCache.png">
<meta property="og:image" content="http://macchac.com/.com//CompareCache.png">
<meta property="article:published_time" content="2021-03-29T10:16:57.000Z">
<meta property="article:modified_time" content="2021-04-03T08:20:50.607Z">
<meta property="article:author" content="Maccha">
<meta property="article:tag" content="基础">
<meta property="article:tag" content="网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://macchac.com/.com//HTTP-Cache.jpg">

<link rel="canonical" href="http://macchac.com/2021/03/29/urll/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>
 
<script>
  var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });
</script>


  <title>当你在浏览器中输入Url之后发生了什么 | 來日可期</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="來日可期" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">來日可期</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">你要努力</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">9</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://macchac.com/2021/03/29/urll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/maccha.gif">
      <meta itemprop="name" content="Maccha">
      <meta itemprop="description" content="一个天理小学弟的进坑之路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="來日可期">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          当你在浏览器中输入Url之后发生了什么
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-29 18:16:57" itemprop="dateCreated datePublished" datetime="2021-03-29T18:16:57+08:00">2021-03-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>
            </span>

          

            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>最近重新过了一遍网络的基础内容，之前看这个问题的时候觉得这个问题也没有多少东西可说，但是现在重新来看这个题目的时候，发现之前是没有一个相对完整的知识体系，这个问题基本上可以囊括一大半的网络基础知识内容<br></p>
<p>本次重新梳理一下这个问题的内容，其实换个角度看，这个问题也是在问HTTP请求的完整过程。</p>
<p>（也当是重新回学校之后开始整理博客的第一篇吧）</p>
<a id="more"></a>

<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ul>
<li><strong>URL解析</strong> 浏览器对网址进行格式化检查，判断是否有效，没有给定协议则默认为Http协议</li>
<li><strong>DNS解析</strong> 根据DNS查询IP地址的过程【浏览器缓存，操作系统缓存，路由器缓存，本地域名服务器缓存，根域名】</li>
<li><strong>协议栈</strong>：通过DNS获取到IP地址之后，就可以把HTTP的传输工作交给操作系统中的协议栈</li>
<li><strong>TCP链接</strong>：三次握手建立连接</li>
<li><strong>HTTP请求</strong>：是否使用缓存？</li>
<li><strong>处理请求</strong>：<ul>
<li>加上IP首部：TCP模块再执行链接，收发，断开等各个阶段操作的时候，都需要委托IP模块将数据封装成网络包发送给通信对象。</li>
<li>机上MAC头部：生辰了IP头部之后，接下来网络包还需要在IP头部加上MAC头部</li>
<li>网卡出关：IP生成的网络包只是存放在内存中的一串二进制数字信号，没办法直接发送给对方，因此我们需要将数字信号转换成电信号，才能在网线中传输，这才是真正数据发送的过程</li>
<li>将包通过交换机传输，交换机根据MAC地址表查询MAC地址，将信号发送给相应的端口</li>
<li>通过路由器传输：网络包经过交换机之后到达路由器，并在此转发到下一个路由器或者目标设备</li>
<li>到达服务器拆解数据包</li>
</ul>
</li>
<li><strong>接受响应</strong>：服务器响应请求：解析请求，生成相应头和具体响应内容：2是正常，3开头是转发重定向，4开头是客户端错误，5开头是服务器错误</li>
<li><strong>浏览器解析</strong>：根据不同的响应状态码处理不同的操作</li>
<li><strong>渲染页面</strong>：浏览器显示HTML界面，想服务器发送请求获取嵌入在HTML中的对象，发送异步请求</li>
<li><strong>关闭TCP请求连接</strong>：根据连接属性判断是否断开连接【四次挥手】</li>
</ul>
<hr>
<h2 id="URL解析"><a href="#URL解析" class="headerlink" title="URL解析"></a><strong>URL解析</strong></h2><p>如：<a href="http://www.macchac.com/2020/01/27/test" target="_blank" rel="noopener">http://www.macchac.com/2020/01/27/test</a>  根据元素组成拆分解析：</p>
<p><strong>http:</strong>  url开头表示访问数组的协议（若没有则默认为http协议）</p>
<p><strong>//</strong>：（//后面的字符串表示服务器的名称、域名）</p>
<p><strong><a href="http://www.macchac.com" target="_blank" rel="noopener">www.macchac.com</a></strong>：服务器的名称或者域名</p>
<p><strong>/2020/01/27/test</strong>：数据源（文件）的路径</p>
<blockquote>
<p>如果数据源地址都省略了那应该请求那个文件？ 请求根目录下事先设置的默认文件 如<strong>index.html</strong></p>
</blockquote>
<p>同时还会进行安全检查，访问限制等</p>
<p><strong>检查缓存</strong></p>
<p><img src="/.com//HTTP-Cache.jpg" alt="HTTP缓存"></p>
<p>根据解析的服务器名称和文件名称生成HTTP请求消息</p>
<hr>
<h2 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a><strong>DNS解析过程</strong></h2><blockquote>
<ul>
<li><p>域名层级关系：</p>
<p>DNS中的域名都适用句号来分割的，比如 <a href="http://www.macchac.com" target="_blank" rel="noopener">www.macchac.com</a>  这里的句号代表了不同层级的分割界限，越靠右的位置表示层级越高。</p>
<p>根域在最顶层，他的下一层就是<strong>com顶级域名</strong>，在下层就是 <strong>macchac.com</strong> </p>
<p>所以域名层级关系类似于一个树状结构：</p>
<ul>
<li>根DNS服务器</li>
<li>顶级域DNS服务器（com）</li>
<li>权威DNS服务器（server.com）</li>
</ul>
</li>
</ul>
<p>根域的DNS服务器信息保存在互联网中所有的DNS服务器中，</p>
<p>这样一来，任何DNS服务器都可以找到并访问跟域DNS服务器了</p>
<p>因此，客户端只要知道服务器名称，找到任意一台DNS服务器，就可以通过它找到根域DNS服务器，然后一路向下找到位于下层的某台目标DNS服务器</p>
</blockquote>
<h3 id="域名解析的工作流程："><a href="#域名解析的工作流程：" class="headerlink" title="域名解析的工作流程："></a><strong>域名解析的工作流程：</strong></h3><p><img src="/.com//endpoint.jpg" alt="域名解析流程"></p>
<p>浏览器先以此查看浏览器、操作系统、host、路由器DNS缓存，如果这中间任何一个环节发现存在此地址的缓存，则直接返回对应的IP地址。如果使用了强缓存，浏览器查看本地强缓存是否过期，</p>
<ul>
<li>若不过期，则返回文件。</li>
<li>如果缓存过期，则建立连接，发送请求拉取资源</li>
</ul>
<p>1、客户端发出一个DNS请求，询问<a href="http://www.macchac.com" target="_blank" rel="noopener">www.macchac.com</a> 的IP是什么，并发给本地的DNS服务器（电信，移动），（客户端TCP/IP中填写的 DNS服务器地址）</p>
<p>2、本地服务器接收到客户端请求之后，查看缓存</p>
<ul>
<li>如果缓存中能够找到<a href="http://www.macchac.com" target="_blank" rel="noopener">www.macchac.com</a> 就直接返回，<ul>
<li>之后浏览器需要根据IP与缓存的对应关系，查看本地强缓存是否过期，</li>
<li>若不过期，返回文件。缓存过期，则建立链接，发送请求拉取资源</li>
</ul>
</li>
<li>如果没有缓存则本地DNS会去询问根域名服务器，根域名服务器是最高层次的，不会参与域名解析，只会指明去下层服务器找（类似于双亲委派机制）</li>
</ul>
<p>3、收到来自本地的DNS的请求之后，发现后置是 <strong>.com</strong> ,就返回 .com 顶级域名服务器地址给客户端，</p>
<p>4、本地DNS 服务器再次请求 .com 顶级域名服务器 询问 <a href="http://www.macchac.com" target="_blank" rel="noopener">www.macchac.com</a>  的IP地址</p>
<p>5、com顶级域名地址找到 <a href="http://www.macchac.com" target="_blank" rel="noopener">www.macchac.com</a> 的权威DNS服务器（负责此域名的DNS服务器）并返回给客户端</p>
<p>6、本地DNS服务器转向询问权威DNS服务器，查询后将对应的 IP 地址 xxx.xxx.xxx.xx告诉本地DNS服务器，</p>
<p>7、本地DNS将IP地址返回给客户端（并建立缓存）</p>
<p>8、浏览器查看本地强缓存是否过期，如果没过期则返回文件，如果过期，则建立连接，发起请求拉取资源</p>
<p><img src="/.com//DNS.png" alt="DNS解析过程"></p>
<h3 id="CDN负载均衡"><a href="#CDN负载均衡" class="headerlink" title="CDN负载均衡"></a>CDN负载均衡</h3><blockquote>
<p> 如果亿万请求全部位于一个机器上，则会出现负载量过大的问题，解决方法就是DNS负载均衡技术：</p>
<p> 在DNS服务器中为同一个主机分配多个IP地址，在应答DNS查询的时候，将客户端的访问引导到不同的机器上去，从而达到负载均衡的目的，比如位于北京的客户端请求一个服务器地址，</p>
<p> 如果使用了CDN加速</p>
</blockquote>
<p><img src="/.com//CDN.png" alt="CDN访问过程"></p>
<blockquote>
<ol>
<li><p>当终端用户（北京）向<code>www.a.com</code>下的指定资源发起请求时，首先向LDNS（本地DNS）发起域名解析请求。</p>
</li>
<li><p>LDNS检查缓存中是否有<code>www.a.com</code>的IP地址记录。如果有，则直接返回给终端用户；如果没有，则向授权DNS查询。</p>
</li>
<li><p>当授权DNS解析<code>www.a.com</code>时，返回域名CNAME <code>www.a.tbcdn.com</code>对应IP地址。</p>
</li>
<li><p>域名解析请求发送至DNS调度系统，并为请求分配最佳节点IP地址。</p>
</li>
<li><p>LDNS获取DNS返回的解析IP地址。</p>
</li>
<li><p>用户获取解析IP地址。</p>
</li>
<li><p>用户向获取的IP地址发起对该资源的访问请求。</p>
<ul>
<li>如果该IP地址对应的节点已缓存该资源，则会将数据直接返回给用户，例如，图中步骤7和8，请求结束。</li>
<li>如果该IP地址对应的节点未缓存该资源，则节点向源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，图中的北京节点，并返回给用户，请求结束。</li>
</ul>
</li>
</ol>
</blockquote>
<hr>
<h2 id="发给协议栈"><a href="#发给协议栈" class="headerlink" title="发给协议栈"></a>发给协议栈</h2><p>通过DNS获取到IP地址之后就可以把HTTP的传输工作交给操作系统的协议栈了</p>
<p><img src="/.com//progress.jpg" alt="协议栈请求过程"></p>
<p><strong>应用层：发送HTTP请求</strong></p>
<p>封装请求报头，请求方式：GET、POST，地址、协议等</p>
<p>请求主体、</p>
<p><strong>传输层：TCP传输报文</strong></p>
<p>​    传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。</p>
<p>​    确认进行TCP三次握手，注意点：SYN洪范攻击</p>
<p><strong>网络层：IP协议查询Mac地址</strong>：</p>
<p>​    将数据段打包，并加入源及目标的IP地址，并且负责寻找传输路线。</p>
<p>​    判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。</p>
<p><strong>链路层：以太网协议</strong></p>
<p>​    Mac地址、广播、接收方单播、注意点：ARP攻击</p>
<p><strong>服务器接受请求</strong>：上述步骤反过来</p>
<hr>
<h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>TCP/IP</p>
<p>三次握手建立可靠的，单点连接</p>
<p><img src="/.com//tcpCenter.png" alt="TCP报文段"></p>
<ul>
<li><p>源端口号和目的端口号确定发送方和接收方，</p>
</li>
<li><p>序号解决包的乱序问题，</p>
</li>
<li><p>确认序号，确认发出去对方是否收到，如果没有收到就应该重新发送，直到送达，为了解决不丢包问题</p>
</li>
<li><p>状态位中：SYN是建立连接标记、ACK是确认回复标记、RST是重新连接标记、FIN是结束连接标记、双方要维护连接的状态，这些标记位的包的更新会引起双方连接的状态变更</p>
</li>
<li><p>窗口大小：</p>
<ul>
<li>TCP要做流量控制，通信双方各声明一个窗口大小（缓存），标识自己当前能够的处理能力，避免发送太快，无法处理，发送太慢，浪费资源</li>
<li>拥塞控制，对于真正的通路堵车不堵车，它无能为力，只能做到的是在网络情况差的时候控制发送数据的速度</li>
</ul>
</li>
</ul>
<blockquote>
<p>TCP在建立连接之前一定要做的就是三次握手：</p>
<p>服务端端口处于LISTEN状态下，一直监听客户端的请求</p>
<p>1、客户端发出建立连接的请求，<strong>SYN=1、seq=x</strong>，等待服务端反馈，进入<strong>SYN-SENT</strong>状态</p>
<p>2、服务端收到请求，返回<strong>SYN=1、ACK=1、seq=y、ack=x+1</strong>，之后进入<strong>SYN-RECV</strong>状态</p>
<p>3、客户端收到服务端发送的确认包，发送确认包 <strong>SYN=1、ACK=1、seq=x+1、ack=y+1</strong>，之后进入<strong>ESTABLISH</strong>状态</p>
<p>4、服务端收到ACK包，进入<strong>ESTABLISHED</strong>状态</p>
</blockquote>
<p><img src="/.com//shackhands.png" alt="三次握手过程"></p>
<h4 id="为什么一定要三次握手（而不是两次、四次）"><a href="#为什么一定要三次握手（而不是两次、四次）" class="headerlink" title="为什么一定要三次握手（而不是两次、四次）"></a>为什么一定要三次握手（而不是两次、四次）</h4><p>TCP连接：用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号、和窗口大小成为连接，主要有下面几个原因：</p>
<h5 id="1、三次握手才能够阻止重复历史连接的初始化（主要原因）"><a href="#1、三次握手才能够阻止重复历史连接的初始化（主要原因）" class="headerlink" title="1、三次握手才能够阻止重复历史连接的初始化（主要原因）"></a>1、三次握手才能够阻止重复历史连接的初始化（主要原因）</h5><h5 id="2、三次握手才能够保证客户端、服务端双方的发送、接收能力正常"><a href="#2、三次握手才能够保证客户端、服务端双方的发送、接收能力正常" class="headerlink" title="2、三次握手才能够保证客户端、服务端双方的发送、接收能力正常"></a>2、三次握手才能够保证客户端、服务端双方的发送、接收能力正常</h5><h5 id="3、三次握手才可以同步双方的初始化序列号"><a href="#3、三次握手才可以同步双方的初始化序列号" class="headerlink" title="3、三次握手才可以同步双方的初始化序列号"></a>3、三次握手才可以同步双方的初始化序列号</h5><h5 id="4、三次握手能够避免资源的浪费"><a href="#4、三次握手能够避免资源的浪费" class="headerlink" title="4、三次握手能够避免资源的浪费"></a>4、三次握手能够避免资源的浪费</h5><p>TCP 建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能</p>
<p>帮助双方同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输</p>
<blockquote>
<p>两次握手：无法防止历史连接的建立，会造成双方的资源浪费，也无法可靠的同步双方的序列号</p>
<p>四次握手：三次握手时理论上最少的可靠连接的建立，更多的通信次数也是资源的浪费</p>
</blockquote>
<hr>
<p><strong>原因一的具体分析：</strong>防止旧的实效连接重复的初始化造成混乱</p>
<p><img src="/.com//shakehand3.png" alt="三次握手避免历史连接"></p>
<p>客户端在某些网络不稳定的情况下发送多个SYN建立连接的请求报文：</p>
<ul>
<li>【旧的SYN报文】比【最新的SYN报文】先到达了服务端</li>
<li>那么此时服务端返回一个ACK包（SYN+ACK）给客户端</li>
<li>客户端接收到之后，能够根据自身的上下文报文序号，判断出这是一个已经失效的历史连接（序列号过期或者超时）那么客户端就会发送RST报文给服务端，终止这次连接</li>
</ul>
<p>如果是两次握手的情况下，服务端不能判断当前连接是否是历史连接，三次握手则可以在客户端准备发送第三次报文的时候，能够根据上下文判断是否是历史连接，</p>
<ul>
<li>如果是历史连接（序列号过期或者失效），客户端返回RST报文，告知服务端端开此次连接请求，终止历史连接</li>
<li>如果不是历史连接，第三次发送的就是ACK报文，双方成功建立连接；</li>
</ul>
<p>所以，TCP使用三次握手建立连接主要原因是为了防止历史连接被重新初始化。</p>
<hr>
<p><strong>原因二的具体分析：</strong> 保证双方的发送、接收能力正常</p>
<p>要想建立起可靠的连接，需要双方都确保自己的发送数据，接收数据能力正常，</p>
<ul>
<li>第一次“握手” 之后，客户端发送SYN包，服务端可以确认自己的接收能力正常，而客户端无任何感知</li>
<li>第二次握手之后， 服务端发送SYN+ACK包，客户端可以确认自己的接收能力和发送能力正常，服务端无感知</li>
<li>第三次握手之后，客户端发送ACK包，服务端可以确认自己的发送能力正常，双方可以开始建立连接通信</li>
</ul>
<p>最少需要三次，其中第二步的SYN和ACK可以拆分成两个数据包发送，变成四次握手，但会因此增加通信次数，不必要</p>
<hr>
<p><strong>原因三的具体分析：</strong>TCP通信双方都需要维护一个系列号，序列号是可靠性传输的一个关键因素：</p>
<ul>
<li>接收方可以去除重复的数据</li>
<li>接收方可以根据数据包的序列号去按顺序接收</li>
<li>可以标识发送出去的数据包中，那一些是已经被对方接收到的；</li>
</ul>
<p>可见序列号在TCP连接中占据非常重要的作用。客户端发送携带【初始序列号】的SYN包，需要服务端返回一个ACK应答包，标识客户端的SYN报文已经被服务端成功接收，当服务端的【初始化序列号】给客户端的时候，依然也要得到客户端的应答回应，这样才能确保双方的初始化序列号能被可靠的同步</p>
<hr>
<p><strong>原因四的具体分析：</strong>两次握手会造成消息滞留，服务端重复接收无用的连接请求SYN报文。导致重复分配资源。</p>
<p>​    如果只有两次握手，当网络不稳定，或者客户端的SYN请求包在网络中发生阻塞，客户端没有接收到ACK报文，就会重新发送建立连接的SYN数据包，由于没有第三次握手，服务端就不清楚客户端是否接收到自己发送的建立连接的ACK确认信号，每次收到一个SYN就主动建立一个连接，会造成重复发送多次SYN报文，服务端也建立多个无用冗余的TCP连接通道，造成了不必要的浪费。</p>
<p><img src="/.com//shakehand2.png" alt="两次握手"></p>
<h4 id="三次握手存在的缺陷"><a href="#三次握手存在的缺陷" class="headerlink" title="三次握手存在的缺陷"></a>三次握手存在的缺陷</h4><h5 id="1、SYN泛洪攻击"><a href="#1、SYN泛洪攻击" class="headerlink" title="1、SYN泛洪攻击"></a>1、SYN泛洪攻击</h5><p>原理：<strong>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的</strong>，所以服务器容易受到SYN洪泛攻击。</p>
<p>​    当大量的攻击者请求建立连接的时候，短时间内伪造出大量不存在的IP地址，向服务器发送SYN请求建立连接，服务器在接受请求之后向该IP回复SYN和ACK，进入SYN_RECV 半连接状态，但是由于找不到对应的IP地址的主机，当超时时服务器无法接收到ACK会进行重复发送直到超时，这种伪造的SYN包长时间占用半连接队列，导致正常的请求因为队列满而无法处理被丢弃，从而引起网络阻塞或者系统瘫痪，</p>
<p>​    防范措施：</p>
<ul>
<li>降低SYN timeout时间，使得主机尽快释放半连接的占用</li>
<li>增加最大半连接队列大小</li>
<li>采用SYN cookie设置，如果短时间内接收到多个相同IP的重复SYN请求，则默认认为受到了攻击，丢弃该IP地址的后续请求报文</li>
<li>在网关处设置过滤，拒绝一个源IP地址不属于其来源子网的包进行更远的路由</li>
</ul>
<h5 id="2、SYN洪范攻击"><a href="#2、SYN洪范攻击" class="headerlink" title="2、SYN洪范攻击"></a>2、SYN洪范攻击</h5><p>​    当客户端发送连接SYN包给服务端之后，服务端返回ACK和SYN，攻击者截获ACK和SYN包，然后伪装成原始主机继续和服务器进行通信，</p>
<p>它通过TCP连接的一个缺陷，向网络服务所在端口发送大量的伪造地址的攻击报文，可能造成目标服务器中的半连接队列被占满，从而阻止服务器响应其他连接请求，主要特征是同一个IP地址发送大量的连接请求，但是都缺少第三次握手的ACK回复，</p>
<p>原理：攻击者伪造地址对服务器进行SYN请求，服务器回应SYN+ACK 而真实的IP地址会认为没有进行发送请求，所以不做回应，服务器没有收到回应，不知道自己发出的包是否成功，就会进行超时重传（默认会进行5次重试）。这样对服务器的内存带宽造成很大的消耗，攻击者如果处在公网，可以伪造IP的话，很难根据IP判断攻击者，给防护带来很大的困难。</p>
<p>​    解决方法：</p>
<ul>
<li>无效连接监视释放</li>
</ul>
<p>这种方法不停地监视系统中的半连接和不活跃的连接，当达到一定阈值的时候就拆除这些连接，主动断开请求释放系统资源，这种绝对公平的处理方式也会对正常的请求进行释放。</p>
<ul>
<li><p>延缓TCB分配资源<br>SYN洪范攻击主要利用了SYN数据报文一到，系统就给TCB分配资源的特点，所以可以从这里入手，两种方式解决</p>
<ul>
<li><p>Syn - Cache技术</p>
<p>这种技术在收到SYN时候不去分配系统资源，而是先回复ACK报文，并在一个HASH表中保存这种半连接状态的连接，直到收到正确的 ACK 报文再去分配资源</p>
</li>
<li><p>Syn - Cookie技术</p>
<p>Cookie技术完全不使用任何存储资源，它使用一种特殊的算法生成seq num，考虑到双方的IP地址和端口都是固定的，并且对方无法知道自己比较固定的一些信息，如MSS、时间等，所以在收到对方的ACK报文之后，重新计算一遍，看其中是否和对方回应报文中的 <strong>Seq Num - 1</strong> 相同，从而决定是否分配系统资源</p>
</li>
</ul>
</li>
<li><p>使用SYN Proxy防火墙</p>
</li>
</ul>
<p>原理：对试图穿越的SYN请求进行验证之后才放行</p>
<hr>
<h4 id="半连接队列"><a href="#半连接队列" class="headerlink" title="半连接队列"></a>半连接队列</h4><p>服务器在第一次接收到客户端的建立请求SYN报文之后，回复一个SYN ACK包，并且将状态更改为SYN_RECV状态，等待客户端返回ACK包才能完全建立连接，而此时的连接状态被称为服务端的半连接状态，服务器会把这种状态下的请求连接都放入到一个队列当中，把这个队列称之为 <strong>半连接队列</strong> 。</p>
<p>当然服务端还维护了一个 <strong>全连接队列</strong> ，就是已经完成三次握手的队列，等待进程调用accept（）函数的时候，会把连接从队列中取出来。如果队列满了就可能发生丢包现象，</p>
<p>SYN-ACK在无法收到响应的数据包的时候会进行重传机制：</p>
<p>服务端发送完成SYN- ACK 包，如果没有收到客户端的 ACK 确认包，会进行首次重传，等待一段时间还没有收到客户确认包，会进行第二次重传，如果重传次数超过规定限度，系统将会将该链接从半连接队列中删除。</p>
<p>每次等待的重传时间不一定相同，一般是指数型增长的，如：1s、2s、4s、8s、</p>
<p><img src="/.com//resend.png" alt="超时重传"></p>
<hr>
<h4 id="三次握手可以携带数据么"><a href="#三次握手可以携带数据么" class="headerlink" title="三次握手可以携带数据么"></a>三次握手可以携带数据么</h4><p>第一次和第二次不可以携带数据，第三次握手可以携带数据返回</p>
<p>前两次握手时还没有确定此次连接的可靠性，无法保证通信双方的发送，接收能力是否正常，如果在此时携带传输数据，不但会使得接收方花费多余的时间，内存空间对报文中的数据进行接收，而且不一定能够传输成功，如果被攻击者利用，在第一次握手中携带大量数据，而不去建立完整的三次握手连接，就会更快的浪费掉服务端的资源，</p>
<p>所以，第一次第二次不可以，因为这样会使得服务器更容易受到攻击，对于第三次握手，客户端已经建立了ESTABLISHED状态，而且也已知服务端的接收和发送数据能力正常，所以在客户端这边看来传输数据是可以的。</p>
<hr>
<h2 id="建立连接之后发起HTTP请求"><a href="#建立连接之后发起HTTP请求" class="headerlink" title="建立连接之后发起HTTP请求"></a>建立连接之后发起HTTP请求</h2><p>封装请求报文：</p>
<h3 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h3><p>请求行、请求头、请求体三个部分组成：</p>
<ul>
<li>请求行包含请求方法 、URL 、协议</li>
</ul>
<p>请求方法包含 8 种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</p>
<p>URL 即请求地址，由 &lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;?&lt;参数&gt; 组成</p>
<p>协议版本即 http 版本号</p>
<ul>
<li>请求头：由关键字的健值对组成，每行一对、关键字和值之间用英文冒号分隔开。</li>
<li>请求体：可以承载多个请求参数、数据</li>
</ul>
<hr>
<h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><p>Http 缓存机制作为 web 性能优化的重要手段，当客户端发送第一次请求数据的时候，浏览器没有相应的缓存数据，需要请求服务器，服务器返回之后，需要判断是否开启缓存，将数据存储到缓存中。</p>
<p><img src="/.com//CacheSimple.png" alt="第一次请求数据"></p>
<p>或者一个请求发送的时候，如果使用了缓存，缓存运作的整体流程如下</p>
<p><img src="/.com//cacheProcess.jpg" alt="缓存请求过程"></p>
<p>缓存分类：</p>
<ul>
<li><p><strong>强制缓存：</strong></p>
<p>不需要发送请求到服务端，直接读取浏览器本地缓存，HTTP状态码为200</p>
<p>在 Chrome 中，强缓存又分为 <strong>Disk Cache（存放在硬盘中）</strong>和 <strong>Memory Cache（存放在内存中</strong>），存放的位置是由浏览器控制的。<strong>是否强缓存由</strong> <strong>Expires</strong>、<strong>Cache-Control</strong> 和 <strong>Pragma</strong> 3 个 Header 属性共同来控制。</p>
</li>
<li><p><strong>对比缓存</strong></p>
<p>当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了 If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。</p>
</li>
</ul>
<blockquote>
<p>我们可以看到两类缓存规则的不同：</p>
<p><strong>强制缓存如果生效，不需要再和服务器发生交互</strong>，</p>
<p>而<strong>对比缓存不管是否生效，都需要与服务端发生交互。</strong></p>
<p>两类缓存规则可以同时存在，<strong>强制缓存优先级高于对比缓存</strong>，也就是说，<strong>当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则</strong></p>
</blockquote>
<hr>
<h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>已经存在缓存数据的时候，仅基于强制缓存下，请求数据的流程是这样子的：</p>
<p><img src="/.com//StrongCache.png" alt="强缓存"></p>
<hr>
<h4 id="对比缓存"><a href="#对比缓存" class="headerlink" title="对比缓存"></a>对比缓存</h4><p>已经存在缓存数据的手，在基于对比缓存下，请求数据的流程如下：</p>
<p><img src="/.com//CompareCache.png" alt="对比缓存"></p>
<hr>
<h2 id="服务器接收、处理请求"><a href="#服务器接收、处理请求" class="headerlink" title="服务器接收、处理请求"></a>服务器接收、处理请求</h2><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag"># 基础</a>
              <a href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag"># 网络</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/07/ClassLoader-Type/" rel="prev" title="类的加载方式">
      <i class="fa fa-chevron-left"></i> 类的加载方式
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#过程"><span class="nav-number">1.</span> <span class="nav-text">过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#URL解析"><span class="nav-number">2.</span> <span class="nav-text">URL解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DNS解析过程"><span class="nav-number">3.</span> <span class="nav-text">DNS解析过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#域名解析的工作流程："><span class="nav-number">3.1.</span> <span class="nav-text">域名解析的工作流程：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CDN负载均衡"><span class="nav-number">3.2.</span> <span class="nav-text">CDN负载均衡</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发给协议栈"><span class="nav-number">4.</span> <span class="nav-text">发给协议栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP连接"><span class="nav-number">4.1.</span> <span class="nav-text">TCP连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么一定要三次握手（而不是两次、四次）"><span class="nav-number">4.1.1.</span> <span class="nav-text">为什么一定要三次握手（而不是两次、四次）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、三次握手才能够阻止重复历史连接的初始化（主要原因）"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">1、三次握手才能够阻止重复历史连接的初始化（主要原因）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、三次握手才能够保证客户端、服务端双方的发送、接收能力正常"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">2、三次握手才能够保证客户端、服务端双方的发送、接收能力正常</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、三次握手才可以同步双方的初始化序列号"><span class="nav-number">4.1.1.3.</span> <span class="nav-text">3、三次握手才可以同步双方的初始化序列号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、三次握手能够避免资源的浪费"><span class="nav-number">4.1.1.4.</span> <span class="nav-text">4、三次握手能够避免资源的浪费</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三次握手存在的缺陷"><span class="nav-number">4.1.2.</span> <span class="nav-text">三次握手存在的缺陷</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、SYN泛洪攻击"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">1、SYN泛洪攻击</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、SYN洪范攻击"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">2、SYN洪范攻击</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#半连接队列"><span class="nav-number">4.1.3.</span> <span class="nav-text">半连接队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三次握手可以携带数据么"><span class="nav-number">4.1.4.</span> <span class="nav-text">三次握手可以携带数据么</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#建立连接之后发起HTTP请求"><span class="nav-number">5.</span> <span class="nav-text">建立连接之后发起HTTP请求</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#结构："><span class="nav-number">5.1.</span> <span class="nav-text">结构：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP缓存"><span class="nav-number">5.2.</span> <span class="nav-text">HTTP缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#强制缓存"><span class="nav-number">5.2.1.</span> <span class="nav-text">强制缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对比缓存"><span class="nav-number">5.2.2.</span> <span class="nav-text">对比缓存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务器接收、处理请求"><span class="nav-number">6.</span> <span class="nav-text">服务器接收、处理请求</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Maccha"
      src="/images/maccha.gif">
  <p class="site-author-name" itemprop="name">Maccha</p>
  <div class="site-description" itemprop="description">一个天理小学弟的进坑之路</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ccancle" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ccancle" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:821161464@qq.com" title="E-Mail → mailto:821161464@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/3457742584" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;3457742584" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Machha</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">23k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">21 分钟</span>
</div><div class="translate-style">
繁/简：<a id="translateLink" href="javascript:translatePage();">繁体
</a>
</div>
<script type="text/javascript" src="/js/tw_cn.js"></script>
<script type="text/javascript">
var defaultEncoding = 2; //网站编写字体是否繁体，1-繁体，2-简体
var translateDelay = 0; //延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0
var cookieDomain = "https://tding.top/"; //Cookie地址, 一定要设定, 通常为你的网址
var msgToTraditionalChinese = "繁体"; //此处可以更改为你想要显示的文字
var msgToSimplifiedChinese = "简体"; //同上，但两处均不建议更改
var translateButtonId = "translateLink"; //默认互换id
translateInitilization();
</script>

 
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js"></script>
<script>
  function timer() {
    var ages = moment.preciseDiff(moment(),moment(20200209,"YYYYMMDD"));
    ages = ages.replace(/years?/, "年");
    ages = ages.replace(/months?/, "月");
    ages = ages.replace(/days?/, "天");
    ages = ages.replace(/hours?/, "小时");
    ages = ages.replace(/minutes?/, "分");
    ages = ages.replace(/seconds?/, "秒");
    ages = ages.replace(/\d+/g, '<span style="color:#1890ff">$&</span>');
    div.innerHTML = `我已在此等候你 ${ages}`;
  }
  var div = document.createElement("div");
  //插入到copyright之后
  var copyright = document.querySelector(".copyright");
  document.querySelector(".footer-inner").insertBefore(div, copyright.nextSibling);
  timer();
  setInterval("timer()",1000)
</script>



        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


  <script async src="/js/cursor/fireworks.js"></script>




  <script src="/js/activate-power-mode.min.js"></script>
  <script>
    POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);
  </script>



<script type="text/javascript" src="/js/fold_action.js"></script>

</body>
</html>
